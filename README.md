# Programming-Assignment-3
## Problem 1
For problem 1, I took the approach mentioned in the textbook as the Lock-Free Linked List; it included the use of a Node class as well as a Window class that lets you view the neighboring nodes. This method involves making logical AND physical removals of the nodes in a linked list (if a node is logically removed, it is technically there but will be passed over or ignored by the other functions). This allows you to not have to use any locks but still make changes to the list without interference from other functions or other threads. In java, this requires the use of an atomicMarkableReference (it has a boolean as well as a reference, allowing you to change its logical existence). I found most of the implementation in the textbook and tweaked it a little for this problem. To generate the gifts, I just made an arraylist and shuffled. This problem is saved under LockFreeList.java because I didnt like how it looked to initialize a list with it being called problem1. It is unfinished, I ran out of tie implementing the run function of the servantThreads.

## Problem 2
Probelm 2 was, in my opinion, a lot simpler; a matrix of 8 x 60 was created (8 sensors, 60 readings for each minute within an hour). A thread was made for each of the 8 sensores and random numbers were generated each "minute" (loop iteration). These values would populate the matrix "tempReadings" and each thread would not interfere with the others because it would only change the row for its given id (e.g. thread 1 only makes changes to row 1, and thus only records readings in that row for the sensor). Getting max/min temps and the distance could easily be calculated after the fact once the matrix had been populated. For the sake of seeing a lot of results, I simulated 24 hours so that this program would simulate an entire day of readings (a higher level loop for hours). This could have been better simulated if things happened more in parallel (each minute could be happening at different times for each thread) and, if I had more time, I would have most likely implemented some states to make sure that no sensor was ahead of the next (although this would require a lot of waiting by the threads). For the sake of this example, I think this simple implementation is enough. 
